import datetime
import re
import tarfile
import typing

from functools import partial
from pathlib import Path

import license_expression

from pycargoebuild import __version__
from pycargoebuild.cargo import PackageMetadata, get_package_metadata
from pycargoebuild.format import format_license_var
from pycargoebuild.license import spdx_to_ebuild


EBUILD_TEMPLATE_START = """\
# Copyright {year} Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

# Autogenerated by pycargoebuild {prog_version}

EAPI=8

CRATES="{crates}"

inherit cargo

DESCRIPTION="{description}"
HOMEPAGE="{homepage}"
SRC_URI="
\t$(cargo_crate_uris)
"

LICENSE="{pkg_license}"
"""

EBUILD_TEMPLATE_CRATE_LICENSE = """\
# Dependent crate licenses
LICENSE+="{crate_licenses}"
"""

EBUILD_TEMPLATE_END = """\
SLOT="0"
KEYWORDS="~amd64"
"""


def get_CRATES(crate_files: typing.Iterable[Path]) -> str:
    """
    Return the value of CRATES for the given crate list
    """
    if not crate_files:
        return ""
    return ("\n" +
            "\n".join(f"\t{p.name[:-6]}" for p in sorted(crate_files)) +
            "\n")


def get_package_LICENSE(pkg_meta: PackageMetadata) -> str:
    """
    Get the value of package's LICENSE string
    """

    spdx = license_expression.get_spdx_licensing()
    if pkg_meta.license is not None:
        parsed_pkg_license = spdx.parse(pkg_meta.license,
                                        validate=True,
                                        strict=True)
        return format_license_var(spdx_to_ebuild(parsed_pkg_license),
                                  prefix='LICENSE="')
    return ""


def get_license_from_crate(path: Path) -> str:
    """
    Read the metadata from specified crate and return its license string
    """

    assert path.name.endswith(".crate")
    with tarfile.open(path, "r:gz") as crate:
        tarf = crate.extractfile(f"{path.name[:-6]}/Cargo.toml")
        if tarf is None:
            raise RuntimeError(f"Cargo.toml not found in {path}")
        with tarf:
            # tarfile.ExFileObject() is IO[bytes] while tomli/tomllib
            # expects BinaryIO -- but it actually is compatible
            # https://github.com/hukkin/tomli/issues/214
            crate_metadata = get_package_metadata(tarf)  # type: ignore
            if crate_metadata.license is None:
                raise RuntimeError(
                    f"Create {path.name} does not specify a license!")
            return crate_metadata.license


def get_crate_LICENSE(crate_files: typing.Iterable[Path]) -> str:
    """
    Get the value of LICENSE string for crates
    """

    spdx = license_expression.get_spdx_licensing()
    crate_licenses = set(map(get_license_from_crate, crate_files))

    # combine crate licenses and simplify the result
    combined_license = " AND ".join(f"( {x} )" for x in crate_licenses)
    parsed_license = spdx.parse(combined_license, validate=True, strict=True)
    if parsed_license is None:
        return ""
    final_license = parsed_license.simplify()
    crate_licenses_str = format_license_var(spdx_to_ebuild(final_license),
                                            prefix='LICENSE+=" ')
    # if it's not a multiline string, we need to prepend " "
    if not crate_licenses_str.startswith("\n"):
        crate_licenses_str = " " + crate_licenses_str
    return crate_licenses_str


def get_ebuild(pkg_meta: PackageMetadata,
               crate_files: typing.Iterable[Path],
               *,
               crate_license: bool = True,
               ) -> str:
    """
    Get ebuild contents for passed contents of Cargo.toml and Cargo.lock.
    """

    template = EBUILD_TEMPLATE_START
    if crate_license:
        template += EBUILD_TEMPLATE_CRATE_LICENSE
    template += EBUILD_TEMPLATE_END

    return template.format(
        crates=get_CRATES(crate_files),
        crate_licenses=get_crate_LICENSE(crate_files),
        description=pkg_meta.description or "",
        homepage=pkg_meta.homepage or "",
        pkg_license=get_package_LICENSE(pkg_meta),
        prog_version=__version__,
        year=datetime.date.today().year)


CRATES_RE = re.compile(
    r"^(?P<start>CRATES=(?P<delim>['\"])).*?(?P=delim)$",
    re.DOTALL | re.MULTILINE)

CRATE_LICENSE_RE = re.compile(
    r"^(?P<start># Dependent crate licenses\n"
    r"LICENSE[+]=(?P<delim>['\"])).*?(?P=delim)$",
    re.DOTALL | re.MULTILINE)


class CountingSubst:
    def __init__(self, repl: typing.Callable[[], str]
                 ) -> None:
        self.count = 0
        self.repl = repl

    def __call__(self, match: re.Match) -> str:
        self.count += 1
        return match.group("start") + self.repl() + match.group("delim")

    def assert_count(self, desc: str, expected: int) -> None:
        if self.count != expected:
            raise RuntimeError(
                f"{desc} matched {self.count} times, {expected} expected")


def update_ebuild(ebuild: str,
                  pkg_meta: PackageMetadata,
                  crate_files: typing.Iterable[Path],
                  *,
                  crate_license: bool = True,
                  ) -> str:
    """
    Update the CRATES and LICENSE in an existing ebuild
    """

    crates_repl = CountingSubst(partial(get_CRATES, crate_files))
    crate_license_repl = CountingSubst(partial(get_crate_LICENSE, crate_files))

    ebuild = CRATE_LICENSE_RE.sub(crate_license_repl,
                                  CRATES_RE.sub(crates_repl, ebuild))

    crates_repl.assert_count("CRATES=", 1)
    crate_license_repl.assert_count(
        "Crate LICENSE+= (with marker comment)", 1 if crate_license else 0)

    return ebuild
